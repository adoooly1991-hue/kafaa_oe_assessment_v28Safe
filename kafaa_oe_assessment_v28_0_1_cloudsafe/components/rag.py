\nimport os, json, pathlib\nfrom typing import List, Dict, Any\n\n# Optional imports\ntry:\n    from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, StorageContext, load_index_from_storage\n    from llama_index.embeddings.openai import OpenAIEmbedding  # example provider\n    _LLAMA_OK = True\nexcept Exception:\n    _LLAMA_OK = False\n\n\n\n# ---------- RAG Helper (Qdrant-preferred with graceful fallback) ----------\nimport os, pathlib\nfrom typing import List, Dict, Any\n\n# Optional heavy deps\n_LLAMA_OK = False\n_QDRANT_OK = False\ntry:\n    from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, StorageContext, load_index_from_storage, Settings\n    from llama_index.embeddings.openai import OpenAIEmbedding  # example; swap if needed\n    from llama_index.vector_stores.qdrant import QdrantVectorStore\n    _LLAMA_OK = True\nexcept Exception:\n    pass\ntry:\ntry:\n    from qdrant_client import QdrantClient\nexcept Exception:\n    module = None\n    _QDRANT_OK = True\nexcept Exception:\n    pass\n\nclass RAGHelper:\n    def __init__(self, base_dir: str = "rag_store"):\n        self.base = pathlib.Path(base_dir)\n        self.base.mkdir(exist_ok=True, parents=True)\n        self.index = None\n        # Qdrant config via env\n        self.q_url = os.getenv("QDRANT_URL", None)\n        self.q_api = os.getenv("QDRANT_API_KEY", None)\n        self.q_collection = os.getenv("QDRANT_COLLECTION", "kafaa_oe_docs")\n\n    def _qdrant_ctx(self):\n        if not (_LLAMA_OK and _QDRANT_OK and self.q_url):\n            return None\n        client = QdrantClient(url=self.q_url, api_key=self.q_api) if self.q_api else QdrantClient(url=self.q_url)\n        vs = QdrantVectorStore(client=client, collection_name=self.q_collection)\n        return StorageContext.from_defaults(vector_store=vs)\n\n    def index_paths(self, paths: List[str]) -> str:\n        # If LlamaIndex not present: fallback to naive store\n        if not _LLAMA_OK:\n            txts = []\n            for p in paths:\n                try: txts.append(open(p, 'r', encoding='utf-8', errors='ignore').read())\n                except Exception: pass\n            (self.base / "fallback_corpus.txt").write_text("\n\n".join(txts), encoding="utf-8")\n            return "fallback"\n        # Build docs\n        docs = []\n        for p in paths:\n            try:\n                d = SimpleDirectoryReader(input_files=[p]).load_data()\n                docs.extend(d)\n            except Exception:\n                pass\n        if not docs:\n            return "empty"\n        # Prefer Qdrant vector store if configured\n        sc = self._qdrant_ctx()\n        if sc:\n            self.index = VectorStoreIndex.from_documents(docs, storage_context=sc)\n            # Qdrant persists in its DB; also drop a small marker locally\n            (self.base / "qdrant_pointer.txt").write_text(f"{self.q_url}|{self.q_collection}", encoding="utf-8")\n            return "qdrant"\n        # Else, local storage\n        self.index = VectorStoreIndex.from_documents(docs)\n        self.index.storage_context.persist(persist_dir=str(self.base))\n        return "local"\n\n    def answer(self, question: str, extra_context: str = "") -> Dict[str, Any]:\n        # LlamaIndex with local store or Qdrant pointer\n        if _LLAMA_OK:\n            try:\n                sc = None\n                if (self.base / "qdrant_pointer.txt").exists():\n                    # use qdrant-backed context\n                    sc = self._qdrant_ctx()\n                elif (self.base / "storage.json").exists() or (self.base / "docstore.json").exists():\n                    sc = StorageContext.from_defaults(persist_dir=str(self.base))\n                if sc:\n                    try:\n                        index = load_index_from_storage(storage_context=sc)\n                    except Exception:\n                        index = None\n                else:\n                    index = None\n                if index:\n                    q = question + ("\nContext:\n"+extra_context if extra_context else "")\n                    resp = index.as_query_engine().query(q)\n                    text = str(resp)\n                    sources = []\n                    try:\n                        for n in getattr(resp, "source_nodes", [])[:5]:\n                            try:\n                                sources.append(getattr(n, "node", n).get_content()[:400])\n                            except Exception:\n                                pass\n                    except Exception:\n                        pass\n                    return {"answer": text, "source_nodes": sources}\n            except Exception:\n                pass\n        # Fallback naive\n        corpus = (self.base / "fallback_corpus.txt")\n        snippet = ""\n        if corpus.exists():\n            t = corpus.read_text(encoding="utf-8", errors="ignore")\n            snippet = t[:1200]\n        return { "answer": f"(Ungrounded draft) {question}\n{extra_context[:400]}", "source_nodes": [snippet] }